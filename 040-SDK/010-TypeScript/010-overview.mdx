---
title: Xata SDK for TypeScript and JavaScript
navTitle: SDK overview
keywords: ['TypeScript', 'TypeScript client', 'javascript', 'js']
description: Use the SDK as a schema-based, schema-less, or an API client
slug: sdk/typescript/overview
published: true
---

TEST

The Xata SDK supports TypeScript definitions for your Xata database schema. It also works with JavaScript.

It has zero dependencies and can run in [Node.js](https://nodejs.org/en/docs), [V8](https://v8.dev/docs), [Deno](https://deno.com/), and [Bun](https://bun.sh/).

## Installation

We recommend installing the [Xata CLI](/docs/getting-started/cli) globally and importing the Xata Client from the [code generated](/docs/getting-started/cli#codegen) by the CLI.

When initializing the Xata CLI with the command `xata init` in a project, the `@xata.io/client` package is installed locally using the current project's package manager. In the event
a package manager can't be determined, the Xata CLI will prompt you to manually install the `@xata.io/client` package.

## Usage

There are three ways to use the SDK:

1. Schema-generated Client: SDK to create/read/update/delete records in a given database following a schema file (with type-safety).
1. Schema-less Client: SDK to create/read/update/delete records in any database without schema validation (with partial type-safety).
1. API Client: SDK to interact with the whole Xata API and all its endpoints.

There are three ways to use the SDK:

- [Schema-generated Client](#schema-generated-client): SDK to create/read/update/delete records in a given database following a schema file (with type-safety).
- [Schema-less Client](#schema-less-client): SDK to create/read/update/delete records in any database without schema validation (with partial type-safety).
- [API Client](#api-client): SDK to interact with the whole Xata API and all its endpoints.

To read more on usage examples please checkout our [API Guide](/api-guide/intro).

### Schema-generated Client

To use the schema-generated client, you need to run the code generator utility that comes with [our CLI](/cli/getting-started).

To run it (and assuming you have configured the project with `xata init`):

```bash
xata codegen
```

In a TypeScript file, start using the generated code like this:

```ts
import { XataClient } from './xata'; // or wherever you chose to generate the client

const xata = new XataClient();
```

The import above will differ if you chose to generate the code in a different location.

The `XataClient` constructor accepts an object with configuration options, like the `fetch` parameter, which is required only if your runtime doesn't provide a global `fetch` function. There's also a `databaseURL` argument that by default will contain a URL pointing to your database (e.g. `https://myworkspace-123abc.eu-west-1.xata.sh/db/databasename`). It can be specified in the constructor to overwrite that value if for whatever reason you need to connect to a different workspace or database.

The code generator will create two TypeScript types for each schema entity. The base one will be an `Identifiable` entity with the internal properties your entity has and the `Record` one will extend it with a set of operations (update, delete, etc...) and some schema metadata (xata version).

```ts
interface User extends Identifiable {
  email?: string | null;
}

type UserRecord = User & XataRecord;

async function initializeDatabase(admin: User): Promise<UserRecord> {
  return xata.db.users.create(admin);
}

const admin = await initializeDatabase({ email: 'admin@example.com' });
await admin.update({ email: 'admin@foo.bar' });
await admin.delete();
```

### Schema-less Client

If you don't have a schema file, or you are building a generic way to interact with Xata, you can use the `BaseClient` class without schema validation.

```ts
import { BaseClient } from '@xata.io/client';

const xata = new BaseClient({
  branch: 'branchname',
  apiKey: 'xau_1234abcdef',
  fetch: fetchImplementation // Required if your runtime doesn't provide a global `fetch` function.
});
```

It works the same way as the code-generated `XataClient` but doesn't provide type-safety for your model.

## Helper methods

The TypeScript SDK provides helper methods for creating types based off of Xata client-generated types.
The following are exported on the `@xata.io/client` package:

- `SelectableColumn` provides a type with the valid columns for a record.
- `SelectedPick` returns a subtype of the record with the requested fields.
- `EditableData` removes built-in record methods and reserved fields.

In the example below we create the type `myUser` with a selection of fields from the client-generated UserRecord:

```ts
import { getXataClient } from './xata';
import { SelectedPick, SelectableColumn, EditableData } from '@xata.io/client';
import { UserRecord } from './xata';

const xata = getXataClient();

const fields: SelectableColumn<UserRecord>[] = ['id', 'name', 'address'];

type myUser = EditableData<SelectedPick<UserRecord, typeof fields>>;
```

## Serializing Xata data-structures

Systems such as [Next.js](https://nextjs.org/) expect the server to send [serialized data-structures](https://developer.mozilla.org/en-US/docs/Glossary/Serialization) to the client. Since the Xata SDK returns records as objects as well as strings, there's a need to serialize content for client-side use. Serialization transforms the data into a structured text format that can be easily sent and rebuilt on the client side.

Xata provides the `.toSerializable()` method within the record objects to help with serialization. To revert serialized data back to its original types on the client side, you can use the JSONData helper from `@xata.io/client`.

An example of a common pattern for this flow in a Next.js system:

```tsx title="/app/page.tsx"
import { getXataClient } from './xata';

const xata = getXataClient();

export default async function Page({ params }: { params: { slug: string } }) {
  // Pull records from the "users" table
  const records = await xata.db.users.getMany();

  // Serialize that content, turning any objects into strings
  const serializedRecords = records.toSerializable();

  // Pass the serialized content to the client component
  return <MyComponent records={serializedRecords} />;
}
```

The `MyComponent` client component can then use `JSONData` from the client to match against Xata's auto-generated types as shown below.

```tsx title="/components/MyComponent.tsx"
'use client';
import { FC } from 'react';
import { JSONData } from '@xata.io/client';
import { UserRecord } from './xata';

interface MyComponentProps {
  // The data we serialized still matches the UserRecord shape
  records: JSONData<UserRecord>;
}

export const MyComponent: FC<MyComponentProps> = ({ records }) => {
  return (
    <>
      {records.map((record) => {
        // Date objects were converted to strings during serialization.
        // We can always revert them to their original form here in the client, as needed
        const date = new Date(record.createdAt);
        const dateFormatted = date.toLocaleString();
        return <p>{dateFormatted}</p>;
      })}
    </>
  );
};
```

### API Design

The Xata SDK to create/read/update/delete records follows the [repository pattern](https://lyz-code.github.io/blue-book/architecture/repository_pattern/). Each table will have a repository object available at `xata.db.[table-name]`.

For example if you have a `users` table, there'll be a repository at `xata.db.users`. If you're using the schema-less client, you can also use the `xata.db.[table-name]` syntax to access the repository but without TypeScript auto-completion.

### API Client

One of the main features of the SDK is the ability to interact with the whole Xata API and perform administrative operations such as creating/reading/updating/deleting workspaces, databases, tables, branches...

To communicate with the SDK we provide a constructor called `XataApiClient` that accepts an API token and an optional fetch implementation method.

```ts
const api = new XataApiClient({ apiKey: process.env.XATA_API_KEY });
```

Once you have initialized the API client, the operations are organized following the same hiearchy as in the [official documentation](https://docs.xata.io). You have different namespaces for each entity (ie. `workspaces`, `databases`, `tables`, `branches`, `users`, `records`...).

```ts
import { XataApiClient } from '@xata.io/client';

const api = new XataApiClient();

 api.workspaces.createWorkspace({
      body: { name: workspaceName }
    })
  data: { name: 'workspace' }
});

await newApi.databases.createDatabase({
      body: {region },
      pathParams: {dbName: "", workspaceId:""}
    })
  workspace,
  database: 'database',
  data: { region: 'eu-west-1' }
});

await newApi.branch.createBranch({
      pathParams: { workspace, region, dbBranchName: `${database}:branch` },
    });
  workspace,
  region: 'eu-west-1',
  database: databaseName,
  branch: 'branch'
});

 await newApi.table.createTable({
      pathParams: { workspace, region, dbBranchName: `${database}:branch`, tableName: 'table' },
    });
  workspace,
  region: 'eu-west-1',
  database: databaseName,
  branch: 'branch',
  table: 'table'
});

await newApi.table.setTableSchema({
      body: {columns: [{name: 'email', type: 'string'}]},
      pathParams: {workspace, region, dbBranchName: `${database}:branch`, tableName: 'table'}
    })
  workspace,
  region: 'eu-west-1',
  database: databaseName,
  branch: 'branch',
  table: 'table',
  schema: { columns: [{ name: 'email', type: 'string' }] }
});

await newApi.records.insertRecord({
      pathParams: { workspace, region, dbBranchName: `${database}:branch`, tableName: 'table' },
    })
  workspace,
  region: 'eu-west-1',
  database: databaseName,
  branch: 'branch',
  table: 'table',
  record: { email: 'example@foo.bar' }
});

 await newApi.records.getRecord({
      pathParams: { workspace, region, dbBranchName: `${database}:branch`, tableName: 'table', recordId: '1' },
    });
  workspace,
  region: 'eu-west-1',
  database: databaseName,
  branch: 'branch',
  table: 'table',
  id: recordId.id
});

await newApi.workspaces.deleteWorkspace({
      pathParams: { workspaceId: workspace }
    });
```

## Limitations

Type recursion is limited to 3 levels in the TypeScript SDK. This is to prevent excessive strain on both the type checker and the language server since each nested level adds computational complexity.

Calls on deeper nested columns will still work, but a TypeScript error may be displayed indicating the type cannot be determined.
